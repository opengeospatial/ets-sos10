<?xml version="1.0" encoding="utf-8"?>
<ctl:package
 xmlns:sosFunctions="https://cite.opengeospatial.org/sos-1.0.0/src/ctl/functions.xml"
 xmlns:ctl="http://www.occamlab.com/ctl"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 xmlns:wms="http://www.opengis.net/wms"
 xmlns:xsd="http://www.w3.org/2001/XMLSchema"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xmlns:parsers="http://www.occamlab.com/te/parsers"
 xmlns:ows="http://www.opengeospatial.net/ows"
 xmlns:xows="http://www.opengis.net/ows"

>


    <ctl:function name="sosFunctions:dateTimeFromISO">
        <ctl:param name="dateString"></ctl:param>
		<ctl:description>Convert a valid ISO 8601 date time to a valid XSL datetime. 
						 It is assumed that dateString has already passed "sosFunctions:isValidDate".
						 dateString is assumed to at least have a year month and day
		</ctl:description>
        <ctl:code>
			<xsl:variable name="dateStringNoSpace" select="replace(normalize-space($dateString), ' ', 'T')"/>	
			<xsl:variable name="newDateString" select="replace($dateString, 'Z', '')"/>			
			<xsl:choose>
				<xsl:when test="contains($newDateString, '.')"> <!-- if it passed validation and has a "." in it, it should be fine -->				
					<xsl:value-of select="$newDateString"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="appendString" select="'T00:00:00+00:00'"/>
					<xsl:variable name="newDateStringLngth" select="string-length($newDateString)"/>
					<xsl:variable name="appendStringLength" select="string-length($appendString)"/>
					<xsl:variable name="totalStringLength"	select="25"/>
					<xsl:variable name="substringToAppend" select="substring($appendString, $appendStringLength - ($totalStringLength - $newDateStringLngth) + 1)"/>
					<xsl:variable name="returnValue" select="concat($newDateString, $substringToAppend)"/>			
					<xsl:value-of select="xsd:dateTime($returnValue)"/>
				</xsl:otherwise>
			</xsl:choose>
			
        </ctl:code>
    </ctl:function>
	

    <ctl:function name="sosFunctions:isValidDate">
        <ctl:param name="dateString">The date to be tested</ctl:param>
		<ctl:description>Check whether a date is a valid ISO 8601 date with at least a day included, or one of the valid constants.</ctl:description>
		<!--ctl:return>Boolean</ctl:return-->
        <ctl:code>	
			<xsl:variable name="isoDateFormatRegex" select="'^([0-9]{4})(-([0-9]{2})(-([0-9]{2})(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2})(:([0-9]{2}))?))?)?))$'"/>
			<xsl:variable name="validDateRegex" select="'^[0-9]{4}-(((0[13578]|(10|12))-(0[1-9]|[1-2][0-9]|3[0-1]))|(02-(0[1-9]|[1-2][0-9]))|((0[469]|11)-(0[1-9]|[1-2][0-9]|30)))$'"/>
			<xsl:variable name="datePortion" select="substring($dateString, 1, 10)"/>						
			<xsl:value-of select="(matches($dateString, $isoDateFormatRegex) 
								and matches($datePortion, $validDateRegex))"/>
        </ctl:code>
    </ctl:function>
	
	<ctl:function name="sosFunctions:isValidTimePeriodPosition">
		<ctl:param name="timePosition">The time position to be tested</ctl:param>
		<ctl:code>
			<xsl:variable name="indeterminateValue" select="$timePosition//@indeterminatePosition"/>
				<xsl:choose>
					<xsl:when test="$timePosition=''">
						<xsl:value-of select="$indeterminateValue = 'now' or $indeterminateValue = 'unknown'"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="((not($indeterminateValue) or $indeterminateValue = 'before' or $indeterminateValue = 'after')
												and
												sosFunctions:isValidDate($timePosition)='true')"/>
					</xsl:otherwise>
				</xsl:choose>				
		</ctl:code>
	</ctl:function>

   <ctl:function name="sosFunctions:isValidOperationName">
        <ctl:param name="operationName">The name of the SOS operation</ctl:param>
        <ctl:return>True/False depending on whether the name is one of the valid SOS operations.</ctl:return>
        <ctl:description>Determines whether the operation name is valid</ctl:description>
        <ctl:code>
			<xsl:value-of select="($operationName='GetCapabilities'
											or $operationName='DescribeFeatureType'
											or $operationName='DescribeSensor'
											or $operationName='DescribeObservationType'
											or $operationName='DescribeResultModel'
											or $operationName='GetObservation'
											or $operationName='GetObservationById'
											or $operationName='GetResult'
											or $operationName='GetFeatureOfInterest'
											or $operationName='GetFeatureOfInterestTime'
											or $operationName='Insert'
											or $operationName='RegisterSensor')"/>																					
        </ctl:code>
    </ctl:function>	
	
    <ctl:function name="sosFunctions:isValidProcedureURN">
        <ctl:param name="urnString">The URN to validate</ctl:param>
        <ctl:return>True/False depending on whether or not the URN is valid</ctl:return>
        <ctl:description>Determines if a procedure URN is valid</ctl:description>
        <ctl:code>
				<xsl:value-of select="(matches($urnString,'^urn:ogc(:(\w|\(|\)|\+|,|-|\.|=|\$|_|!|\*|''|@|;)+)+$', 'i'))"/>								
        </ctl:code>
    </ctl:function>	

	
    <ctl:function name="sosFunctions:isValidDefinitionURN">
        <ctl:param name="urnString">The URN to validate</ctl:param>
        <ctl:return>True/False depending on whether or not the URN is valid</ctl:return>
        <ctl:description>Determines if a definition URN is valid. Note that the "version" part is optional</ctl:description>
        <ctl:code>
			<xsl:variable name="urnRegexNoVersion" select="'^urn:ogc:def(:(\w|\(|\)|\+|,|-|\.|=|\$|_|!|\*|''|@|;)+){3}$'"/>
			<xsl:variable name="urnRegexWithVersion" select="'^urn:ogc:def(:(\w|\(|\)|\+|,|-|\.|=|\$|_|!|\*|''|@|;)+){2}:([0-9])+(\.([0-9]+))*:(\w|\(|\)|\+|,|-|\.|=|\$|_|!|\*|''|@|;)+$'"/>
			<xsl:value-of select="(matches($urnString, $urnRegexNoVersion,'i') or matches($urnString, $urnRegexWithVersion,'i'))"/>							
        </ctl:code>
    </ctl:function>	

	<ctl:function name="sosFunctions:isValidMIMETypeFormat">
		<ctl:param name="responseFormat">The respsonseFormat to validate</ctl:param>
		<ctl:return>True/False depending on whether the input is a valid MIME type based on ows:owsCommon.xsd</ctl:return>
		<ctl:description>Determines if a definition URN is valid</ctl:description>
		<ctl:code>		
			<xsl:value-of select="(matches($responseFormat,'^(application|audio|image|text|video|message|multipart|model)/.+(;\s*.+=.+)*','i'))"/>
			<!--xsl:value-of select="(matches($responseFormat,'^text/xml;subtype=.*(OM|TML).*','i'))"/-->
		</ctl:code>
	</ctl:function>	
   

    <ctl:function name="sosFunctions:isValidResultModel">
        <ctl:param name="resultModel">The resultModel to validate</ctl:param>
        <ctl:return>True/False depending on whether the result model is a qualified name of a member of the om:AbstractObservation substitution group.</ctl:return>
        <ctl:description>Determines whether the result model is valid</ctl:description>
        <ctl:code>
			<xsl:value-of select="($resultModel = 'Measurement'
									or $resultModel = 'CountObservation'
									or $resultModel = 'CategoryObservation'
									or $resultModel = 'TruthObservation'
									or $resultModel = 'ComplexObservation'
									or $resultModel = 'DiscreteCoverageObservationType'
									or $resultModel = 'PointCoverageObservationType'
									or $resultModel = 'TimeSeriesObservationType'
									or $resultModel = 'ElementCoverageObservationType'
									or $resultModel = 'DiscreteCoverageObsType'
									or $resultModel = 'PointCoverageObsType'
									or $resultModel = 'TimeSeriesObsType'
									or $resultModel = 'CommonObservationType')"/>							
									
        </ctl:code>
    </ctl:function>	
	
    <ctl:function name="sosFunctions:operationPostURL">
		<ctl:param name="capabilitesDocument">The capabilities document</ctl:param>
        <ctl:param name="operation">The operation for which the URL is reqested</ctl:param>
        <ctl:return>Post URL of given operation</ctl:return>
        <ctl:description>Returns post URL of given operation</ctl:description>
        <ctl:code>
			<xsl:value-of select="$capabilitesDocument//ows:Operation[@name=$operation]/ows:DCP/ows:HTTP/ows:Post/@xlink:href"/>																
        </ctl:code>
    </ctl:function>	

    <ctl:function name="sosFunctions:operationVersion">
		<ctl:param name="capabilitesDocument">The capabilities document</ctl:param>
        <ctl:param name="operation">The operation for which the URL is reqested</ctl:param>
        <ctl:return>Post URL of given operation</ctl:return>
        <ctl:description>Returns post URL of given operation</ctl:description>
        <ctl:code>
			<xsl:value-of select="$capabilitesDocument//ows:Operation[@name=$operation]/ows:Parameter[@name='version']/ows:Value"/>																
        </ctl:code>
    </ctl:function>	

    <ctl:function name="sosFunctions:describeSensorValidProcedure">
		<ctl:param name="capabilitesDocument">The capabilities document</ctl:param>        
        <ctl:return>The first procedure for DescribeSensor advertised in the capabilities document</ctl:return>
        <ctl:description>Return a valid procedure for use in calling DescribeSensor</ctl:description>
        <ctl:code>
			<xsl:value-of select="$capabilitesDocument//ows:Operation[@name='DescribeSensor']/ows:Parameter[@name='procedure']/ows:Value[1]"/>																
        </ctl:code>
    </ctl:function>	
	
    <ctl:function name="sosFunctions:describeSensorOutputFormat">
		<ctl:param name="capabilitesDocument">The capabilities document</ctl:param>        
        <ctl:return>The outputFormat for DescribeSensor advertised in the capabilities document</ctl:return>
        <ctl:description>Return a valid outputFormat for use in calling DescribeSensor</ctl:description>
        <ctl:code>
			<xsl:value-of select="$capabilitesDocument//ows:Operation[@name='DescribeSensor']/ows:Parameter[@name='outputFormat']/ows:Value[1]"/>																
        </ctl:code>
    </ctl:function>	
	
	
	<!--Validates response against schema-->

    <ctl:function name="sosFunctions:xmlValidatingParser">
        <ctl:param name="schemaLocation">The location of the schema used to validate response document</ctl:param>
		<ctl:param name="request">The name of the request</ctl:param>
		<ctl:param name="service">The name of the service</ctl:param>
		<ctl:description>Standard CTL XMLValidatingParser</ctl:description>
        <ctl:code>	
			<xsl:variable name="schemaFile" select="concat($schemaLocation, lower-case($service), $request, '.xsd')"/>
			<xsl:choose>
				<xsl:when test="starts-with($schemaLocation,'http')">
					<!-- note that the ignoreErrors flag below seems to have the opposite of it's intended effect -->
					<parsers:XMLValidatingParser ignoreErrors="true">
						<parsers:schemas>
							<parsers:schema type="url">
								<xsl:value-of select="$schemaFile"/>
							</parsers:schema>
						</parsers:schemas>
					</parsers:XMLValidatingParser>	
				</xsl:when>
				<xsl:otherwise>
					<parsers:XMLValidatingParser ignoreErrors="true">
						<parsers:schemas>
							<parsers:schema type="file">
								<xsl:value-of select="$schemaFile"/>
							</parsers:schema>
						</parsers:schemas>
					</parsers:XMLValidatingParser>
				</xsl:otherwise>
			</xsl:choose>				
        </ctl:code>
    </ctl:function>
	
	<!-- this function does not work -->
	<ctl:function name="sosFunctions:getCapabilitiesRequest">
		<ctl:param name="serviceURL">URL of the SOS</ctl:param>
		<ctl:param name="sosSchemaURL">URL of the SOS schema used to validate response</ctl:param>
		<ctl:code>		
			<!--xsl:variable name="getCapabilitiesRequest"-->
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$serviceURL"/>
					</ctl:url>
					<ctl:method>get</ctl:method>						
					<ctl:param name="request">GetCapabilities</ctl:param>
					<ctl:param name="service">SOS</ctl:param> 
					<!--
					<ctl:call-function name="sosFunctions:xmlValidatingParser">					
					<ctl:with-param name="schemaURL" select="$sosSchemaURL"/>
						<ctl:with-param name="request" select="'GetCapabilities'"/>
						<ctl:with-param name="service" select="'sos'"/>
					</ctl:call-function>	
					-->
				</ctl:request>
				<!--/xsl:variable-->			
			<!--xsl:value-of select="$getCapabilitiesRequest"/-->			
		</ctl:code>
	</ctl:function>
	
    <!-- functions below here are not being used -->
    <!--Validates an ExceptionReport-->
    <ctl:function name="sosFunctions:validateExceptionReport">
        <ctl:param name="exceptionReport">The exception report document to validate</ctl:param>
        <ctl:return>The exception report if it's valid</ctl:return>
        <ctl:description>Validates a returned exception report according to its schema and determines if it is an appropriate exception report for an sos</ctl:description>
        <ctl:code>
            <parsers:XMLValidatingParser>
                <parsers:schemas>
                    <parsers:schema type="url">
                        <!--Link to appropriate schema-->
                    </parsers:schema>
                </parsers:schemas>
            </parsers:XMLValidatingParser>
        </ctl:code>
    </ctl:function>
    
    <!--Validates a SensorML document-->
    <ctl:function name="sosFunctions:validateSensorML">
        <ctl:param name="sensorMLDocument">The SensorML document to validate</ctl:param>
        <ctl:return>The SensorML document if it's valid</ctl:return>
        <ctl:description>Validates a SensorML document according to its schema</ctl:description>
        <ctl:code>
            <parsers:XMLValidatingParser>
                <parsers:schemas>
                    <parsers:schema type="url">
                        <!--Link to appropriate schema-->
                    </parsers:schema>
                </parsers:schemas>
            </parsers:XMLValidatingParser>
        </ctl:code>
    </ctl:function>
    
    <!--Validates a TML document-->
    <ctl:function name="sosFunctions:validateTML">
        <ctl:param name="tmlDocument">The TML document to validate</ctl:param>
        <ctl:return>The TML document if it's valid</ctl:return>
        <ctl:description>Validates a TML document according to its schema</ctl:description>
        <ctl:code>
            <parsers:XMLValidatingParser>
                <parsers:schemas>
                    <parsers:schema type="url">
                        <!--Link to appropriate schema-->
                    </parsers:schema>
                </parsers:schemas>
            </parsers:XMLValidatingParser>
        </ctl:code>
    </ctl:function>
    
    <!--Validates a GetCapabilities response-->
    <ctl:function name="sosFunctions:validateGetCapabilitiesResponse">
        <ctl:param name="getCapabilitiesResponseDocument">The GetCapabilitiesResponse document to validate</ctl:param>
        <ctl:return>The GetCapabilitiesResponse document if it's valid</ctl:return>
        <ctl:description>Validates a GetCapabilitiesResponse document according to its schema</ctl:description>
        <ctl:code>
            <parsers:XMLValidatingParser>
                <parsers:schemas>
                    <parsers:schema type="url">
                        <!--Link to appropriate schema-->
                    </parsers:schema>
                </parsers:schemas>
            </parsers:XMLValidatingParser>
        </ctl:code>
    </ctl:function>

	<!--Validates a DescribeSensor response-->
    <ctl:function name="sosFunctions:validateDescribeSensorResponse">
        <ctl:param name="describeSensorResponseDocument">The DescribeSensorResponse document to validate</ctl:param>
        <ctl:return>The DescribeSensorResponse document if it's valid</ctl:return>
        <ctl:description>Validates a DescribeSensorResponse document according to its schema</ctl:description>
        <ctl:code>
            <parsers:XMLValidatingParser>
                <parsers:schemas>
                    <parsers:schema type="url">
                        <!--Link to appropriate schema-->
                    </parsers:schema>
                </parsers:schemas>
            </parsers:XMLValidatingParser>
        </ctl:code>
    </ctl:function>
    
    <!--Validates a GetObservation response-->
    <ctl:function name="sosFunctions:validateGetObservationResponse">
        <ctl:param name="getObservationResponseDocument">The GetObservationResponse document to validate</ctl:param>
        <ctl:return>The GetObservationResponse document if it's valid</ctl:return>
        <ctl:description>Validates a GetObservationResponse document according to its schema</ctl:description>
        <ctl:code>
            <parsers:XMLValidatingParser>
                <parsers:schemas>
                    <parsers:schema type="url">
                        <!--Link to appropriate schema-->
                    </parsers:schema>
                </parsers:schemas>
            </parsers:XMLValidatingParser>
        </ctl:code>
    </ctl:function>
    
    <!--Validates a Response document-->
	<!--
    <ctl:function name="sosFunctions:validateResponse">
        <ctl:param name="responseDocument">The response document to validate</ctl:param>
        <ctl:return>The response if it's valid</ctl:return>
        <ctl:description>Validates a returned document according to the appropriate schema</ctl:description>
        <ctl:code>
            <xsl:variable name="rootElementName" select="local-name-from-QName(node-name($responseDocument/*))" />
            <xsl:choose>
                <xsl:when test="$rootElementName='SensorML'">
                    <ctl:call-function name="sosFunctions:validateSensorML">
                        <with-param name="sensorMLDocument" select="$responseDocument" />
                    </ctl:call-function>
                </xsl:when>
                <xsl:when test="$rootElementName='tml'">
                    <ctl:call-function name="sosFunctions:validateTML">
                        <with-param name="tmlDocument" select="$responseDocument" />
                    </ctl:call-function>
                </xsl:when>
                <xsl:when test="$rootElementName='Observation'">
                    <ctl:call-function name="sosFunctions:validateGetObservationResponse">
                        <with-param name="getObservationResponseDocument" select="$responseDocument" />
                    </ctl:call-function>
                </xsl:when>
                <xsl:when test="$rootElementName='SensorDescription'">
                    <ctl:call-function name="sosFunctions:validateDescribeResponse">
                        <with-param name="describeSensorResponseDocument" select="$responseDocument" />
                    </ctl:call-function>
                </xsl:when>
                <xsl:otherwise>
                    <ctl:message>The response document was not validated.</ctl:message>
                </xsl:otherwise>
            </xsl:choose>
        </ctl:code>
    </ctl:function>
    -->
    <!--Check for a valid URN-->
    <ctl:function name="sosFunctions:validateURN">
        <ctl:param name="urnString">The URN to validate</ctl:param>
        <ctl:return>True/False depending on whether or not the URN is valid</ctl:return>
        <ctl:description>Determines if a URN is valid</ctl:description>
        <ctl:code>
            <xsl:value-of select="string-length($urnString)>0 and matches($urnString,'[Uu][Rr][Nn]:')"/> <!--([^\s.]+|\.(?!\s))+')" / -->
        </ctl:code>
    </ctl:function>
    
    <!--Get the current Date/Time-->
    <ctl:function name="sosFunctions:getCurrentDateTime">
        <ctl:return>The current Date/Time</ctl:return>
        <ctl:description>Returns the current Date/Time</ctl:description>
        <ctl:java class="net.opengis.sos.getCurrentDateTime" method="getCurrentDateTime" />
    </ctl:function>
    
    <!--Checks a time value to ensure that it is properly formatted and that it occurs after the compareTime-->

    <ctl:function name="sosFunctions:checkTime">
        <ctl:param name="timeToCheck">The time value to check for correctness</ctl:param>
        <ctl:param name="compareTime">The value to compare this time value to</ctl:param>
        <ctl:return>True if the time to check is valid; false otherwise</ctl:return>
        <ctl:description>Checks that the supplied timeToCheck value is a valid time and that it occurs on or after the compareTime</ctl:description>
        <ctl:code>
            <xsl:value-of select="string-length(normalize-space($timeToCheck))>0 and ($timeToCheck)>=($compareTime)" />
        </ctl:code>
    </ctl:function>

</ctl:package>
