<?xml version="1.0" encoding="utf-8"?>
<ctl:package
 xmlns:sosFunctions="https://cite.opengeospatial.org/sos-1.0.0/src/ctl/functions.xml"
 xmlns:ctl="http://www.occamlab.com/ctl"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 xmlns:wms="http://www.opengis.net/wms"
 xmlns:xsd="http://www.w3.org/2001/XMLSchema"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xmlns:parsers="http://www.occamlab.com/te/parsers"
 xmlns:yows="http://www.opengeospatial.net/ows"
 xmlns:ows="http://www.opengis.net/ows/1.1"
 xmlns:xows="http://www.opengis.net/ows"

>


    <ctl:function name="sosFunctions:dateTimeFromISO">
        <ctl:param name="dateString"></ctl:param>
		<ctl:description>Convert a valid ISO 8601 date time to a valid XSL datetime. 
						 It is assumed that dateString has already passed "sosFunctions:isValidDate".
						 dateString is assumed to at least have a year month and day
		</ctl:description>
        <ctl:code>
			<xsl:variable name="dateStringNoSpace" select="replace(normalize-space($dateString), ' ', 'T')"/>	
			<xsl:variable name="newDateString" select="replace($dateString, 'Z', '')"/>			
			<xsl:choose>
				<xsl:when test="contains($newDateString, '.')"> <!-- if it passed validation and has a "." in it, it should be fine -->				
					<xsl:value-of select="$newDateString"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="appendString" select="'T00:00:00+00:00'"/>
					<xsl:variable name="newDateStringLngth" select="string-length($newDateString)"/>
					<xsl:variable name="appendStringLength" select="string-length($appendString)"/>
					<xsl:variable name="totalStringLength"	select="25"/>
					<xsl:variable name="substringToAppend" select="substring($appendString, $appendStringLength - ($totalStringLength - $newDateStringLngth) + 1)"/>
					<xsl:variable name="returnValue" select="concat($newDateString, $substringToAppend)"/>			
					<xsl:value-of select="xsd:dateTime($returnValue)"/>
				</xsl:otherwise>
			</xsl:choose>
			
        </ctl:code>
    </ctl:function>
	

    <ctl:function name="sosFunctions:isValidDate">
        <ctl:param name="dateString">The date to be tested</ctl:param>
		<ctl:description>Check whether a date is a valid ISO 8601 date with at least a day included, or one of the valid constants.</ctl:description>
		<!--ctl:return>Boolean</ctl:return-->
        <ctl:code>	
			<xsl:variable name="isoDateFormatRegex" select="'^([0-9]{4})(-([0-9]{2})(-([0-9]{2})(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2})(:([0-9]{2}))?))?)?))$'"/>
			<xsl:variable name="validDateRegex" select="'^[0-9]{4}-(((0[13578]|(10|12))-(0[1-9]|[1-2][0-9]|3[0-1]))|(02-(0[1-9]|[1-2][0-9]))|((0[469]|11)-(0[1-9]|[1-2][0-9]|30)))$'"/>
			<xsl:variable name="datePortion" select="substring($dateString, 1, 10)"/>						
			<xsl:value-of select="(matches($dateString, $isoDateFormatRegex) 
								and matches($datePortion, $validDateRegex))"/>
        </ctl:code>
    </ctl:function>
	
	<ctl:function name="sosFunctions:isValidTimePeriodPosition">
		<ctl:param name="timePosition">The time position to be tested</ctl:param>
		<ctl:code>
			<xsl:variable name="indeterminateValue" select="$timePosition//@indeterminatePosition"/>
				<xsl:choose>
					<xsl:when test="$timePosition=''">
						<xsl:value-of select="$indeterminateValue = 'now' or $indeterminateValue = 'unknown'"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="((not($indeterminateValue) or $indeterminateValue = 'before' or $indeterminateValue = 'after')
												and
												sosFunctions:isValidDate($timePosition)='true')"/>
					</xsl:otherwise>
				</xsl:choose>				
		</ctl:code>
	</ctl:function>

   <ctl:function name="sosFunctions:isValidOperationName">
        <ctl:param name="operationName">The name of the SOS operation</ctl:param>
        <ctl:return>True/False depending on whether the name is one of the valid SOS operations.</ctl:return>
        <ctl:description>Determines whether the operation name is valid</ctl:description>
        <ctl:code>
			<xsl:value-of select="($operationName='GetCapabilities'
											or $operationName='DescribeFeatureType'
											or $operationName='DescribeSensor'
											or $operationName='DescribeObservationType'
											or $operationName='DescribeResultModel'
											or $operationName='GetObservation'
											or $operationName='GetObservationById'
											or $operationName='GetResult'
											or $operationName='GetFeatureOfInterest'
											or $operationName='GetFeatureOfInterestTime'
											or $operationName='Insert'
											or $operationName='RegisterSensor')"/>																					
        </ctl:code>
    </ctl:function>	
	
    <ctl:function name="sosFunctions:isValidProcedureURN">
        <ctl:param name="urnString">The URN to validate</ctl:param>
        <ctl:return>True/False depending on whether or not the URN is valid</ctl:return>
        <ctl:description>Determines if a procedure URN is valid</ctl:description>
        <ctl:code>
				<xsl:value-of select="(matches($urnString,'^urn:ogc(:(\w|\(|\)|\+|,|-|\.|=|\$|_|!|\*|''|@|;)+)+$', 'i'))"/>								
        </ctl:code>
    </ctl:function>	

	
    <ctl:function name="sosFunctions:isValidDefinitionURN">
        <ctl:param name="urnString">The URN to validate</ctl:param>
        <ctl:return>True/False depending on whether or not the URN is valid</ctl:return>
        <ctl:description>Determines if a definition URN is valid. Note that the "version" part is optional</ctl:description>
        <ctl:code>
			<xsl:variable name="urnRegexNoVersion" select="'^urn:ogc:def(:(\w|\(|\)|\+|,|-|\.|=|\$|_|!|\*|''|@|;)+){3}$'"/>
			<xsl:variable name="urnRegexWithVersion" select="'^urn:ogc:def(:(\w|\(|\)|\+|,|-|\.|=|\$|_|!|\*|''|@|;)+){2}:([0-9])+(\.([0-9]+))*:(\w|\(|\)|\+|,|-|\.|=|\$|_|!|\*|''|@|;)+$'"/>
			<xsl:value-of select="(matches($urnString, $urnRegexNoVersion,'i') or matches($urnString, $urnRegexWithVersion,'i'))"/>							
        </ctl:code>
    </ctl:function>	

	<ctl:function name="sosFunctions:isValidMIMETypeFormat">
		<ctl:param name="responseFormat">The respsonseFormat to validate</ctl:param>
		<ctl:return>True/False depending on whether the input is a valid MIME type based on ows:owsCommon.xsd</ctl:return>
		<ctl:description>Determines if a definition URN is valid</ctl:description>
		<ctl:code>		
			<xsl:value-of select="(matches($responseFormat,'^(application|audio|image|text|video|message|multipart|model)/.+(;\s*.+=.+)*','i'))"/>
			<!--xsl:value-of select="(matches($responseFormat,'^text/xml;subtype=.*(OM|TML).*','i'))"/-->
		</ctl:code>
	</ctl:function>	
   

    <ctl:function name="sosFunctions:isValidResultModel">
        <ctl:param name="resultModel">The resultModel to validate</ctl:param>
        <ctl:return>True/False depending on whether the result model is a qualified name of a member of the om:AbstractObservation substitution group.</ctl:return>
        <ctl:description>Determines whether the result model is valid</ctl:description>
        <ctl:code>
			<xsl:value-of select="($resultModel = 'Measurement'
									or $resultModel = 'CountObservation'
									or $resultModel = 'CategoryObservation'
									or $resultModel = 'TruthObservation'
									or $resultModel = 'ComplexObservation'
									or $resultModel = 'DiscreteCoverageObservationType'
									or $resultModel = 'PointCoverageObservationType'
									or $resultModel = 'TimeSeriesObservationType'
									or $resultModel = 'ElementCoverageObservationType'
									or $resultModel = 'DiscreteCoverageObsType'
									or $resultModel = 'PointCoverageObsType'
									or $resultModel = 'TimeSeriesObsType'
									or $resultModel = 'CommonObservationType')"/>							
									
        </ctl:code>
    </ctl:function>	
	
    <ctl:function name="sosFunctions:operationPostURL">
		<ctl:param name="capabilitesDocument">The capabilities document</ctl:param>
        <ctl:param name="operation">The operation for which the URL is reqested</ctl:param>
        <ctl:return>Post URL of given operation</ctl:return>
        <ctl:description>Returns post URL of given operation</ctl:description>
        <ctl:code>
			<xsl:value-of select="$capabilitesDocument//ows:Operation[@name=$operation]/ows:DCP/ows:HTTP/ows:Post/@xlink:href"/>						         
        </ctl:code>
    </ctl:function>	

    <ctl:function name="sosFunctions:operationVersion">
		<ctl:param name="capabilitesDocument">The capabilities document</ctl:param>
        <ctl:param name="operation">The operation for which the URL is reqested</ctl:param>
        <ctl:return>Post URL of given operation</ctl:return>
        <ctl:description>Returns post URL of given operation</ctl:description>
        <ctl:code>
			<xsl:value-of select="$capabilitesDocument//ows:Operation[@name=$operation]/ows:Parameter[@name='version']//ows:AllowedValues/ows:Value"/>																
        </ctl:code>
    </ctl:function>	

    <ctl:function name="sosFunctions:describeSensorFirstProcedure">
		<ctl:param name="capabilitesDocument">The capabilities document</ctl:param>        
        <ctl:return>The first procedure for DescribeSensor advertised in the capabilities document</ctl:return>
        <ctl:description>Return a valid procedure for use in calling DescribeSensor</ctl:description>
        <ctl:code>
			<xsl:value-of select="$capabilitesDocument//ows:Operation[@name='DescribeSensor']//ows:Parameter[@name='procedure']//ows:AllowedValues/ows:Value[1]"/>																
        </ctl:code>
    </ctl:function>	

    <ctl:function name="sosFunctions:procedureCollection">
		<ctl:param name="capabilitesDocument">The capabilities document</ctl:param>        
        <ctl:return>The first procedure for DescribeSensor advertised in the capabilities document</ctl:return>
        <ctl:description>Return a valid procedure for use in calling DescribeSensor</ctl:description>
        <ctl:code>
			<xsl:value-of select="$capabilitesDocument//ows:Operation[@name='DescribeSensor']/ows:Parameter[@name='procedure']"/>																
        </ctl:code>
    </ctl:function>	
	
    <ctl:function name="sosFunctions:describeSensorOutputFormat">
		<ctl:param name="capabilitesDocument">The capabilities document</ctl:param>        
        <ctl:return>The outputFormat for DescribeSensor advertised in the capabilities document</ctl:return>
        <ctl:description>Return a valid outputFormat for use in calling DescribeSensor</ctl:description>
        <ctl:code>
			<xsl:value-of select="$capabilitesDocument//ows:Operation[@name='DescribeSensor']//ows:Parameter[@name='outputFormat']//ows:AllowedValues/ows:Value[1]"/>																
        </ctl:code>
    </ctl:function>	
	
	<ctl:function name="sosFunctions:schemaPath">
        <ctl:param name="schemaRoot">The location of the schemas</ctl:param>
		<ctl:param name="version">The numeric version of the schema</ctl:param>
		<ctl:param name="encoding">The name of the service or encoding to be used</ctl:param>
		<ctl:param name="filename">Filenam of schema file</ctl:param>	
		<ctl:code>			
			<xsl:value-of select="concat($schemaRoot, $encoding, '/', $version, '/', $filename)"/>
		</ctl:code>
	</ctl:function>
	<!--Validates response against schema-->

    <ctl:function name="sosFunctions:xmlValidatingParser">
        <ctl:param name="schemaRoot">The location of the schemas</ctl:param>
		<ctl:param name="version">The numeric version of the schema</ctl:param>
		<ctl:param name="encoding">The name of the service or encoding to be used</ctl:param>
		<ctl:param name="filename">Filenam of schema file</ctl:param>
		<ctl:description>Standard CTL XMLValidatingParser</ctl:description>
        <ctl:code>			
			<xsl:variable name="schemaFile" select="sosFunctions:schemaPath($schemaRoot, $version, $encoding, $filename)"/>
			<xsl:choose>
				<xsl:when test="starts-with($schemaRoot,'http')">
					<!-- note that the ignoreErrors flag below seems to have the opposite of it's intended effect -->
					<parsers:XMLValidatingParser ignoreErrors="true">
						<parsers:schemas>
							<parsers:schema type="url">
								<xsl:value-of select="$schemaFile"/>
							</parsers:schema>
						</parsers:schemas>
					</parsers:XMLValidatingParser>	
				</xsl:when>
				<xsl:otherwise>
					<parsers:XMLValidatingParser ignoreErrors="true">
						<parsers:schemas>
							<parsers:schema type="file">
								<xsl:value-of select="$schemaFile"/>
							</parsers:schema>
						</parsers:schemas>
					</parsers:XMLValidatingParser>
				</xsl:otherwise>
			</xsl:choose>				
        </ctl:code>
    </ctl:function>
	
	<!-- the follwing three functions parse out subtype parts from a mime type -->
	<ctl:function name="sosFunctions:mimeSubtype">
        <ctl:param name="mimeType">The mime type</ctl:param>
		<ctl:code>			
			<xsl:value-of select="replace(substring-after($mimeType, 'subtype='), '&quot;', '')"/>
		</ctl:code>
	</ctl:function>	
	
	<ctl:function name="sosFunctions:mimeTypeSubtypeEncoding">
        <ctl:param name="mimeType">The mime type</ctl:param>
		<ctl:code>			
			<xsl:value-of select="substring-before(sosFunctions:mimeSubtype($mimeType), '/')"/>
		</ctl:code>
	</ctl:function>
	
	<ctl:function name="sosFunctions:mimeTypeSubtypeVersion">
        <ctl:param name="mimeType">The mime type</ctl:param>
		<ctl:code>			
			<xsl:value-of select="substring-after(sosFunctions:mimeSubtype($mimeType), '/')"/>
		</ctl:code>
	</ctl:function>
	

	
</ctl:package>
